# RMNote

## 구현 내용

  1. 데이터 스키마 정의 및 DB 호출, 저장 함수

    - 기존 DB는 로컬스토리지의 한 키(rmonte)에 전부 저장하며, 가장 상위의 노트북들의 목록을 기준 문서로 하고 하위에 여러 번 중첩된 문서를 추가하도록 해 앱에서 보이는 것과 같게 직관적으로 구현했습니다.
    - 기존의 데이터는 해당 데이터의 id를 키로 하여 저장했는데, nested 노트북을 구현한다면 노트북과 노트를 구분할 필요가 생깁니다.
    - 처음에는 데이터에 type 속성을 추가해 구분하려고 했으나, 노트북의 키 값과 노트의 키 값이 마구 섞여 있어, 서로의 데이터를 오염 시키거나 잘못된 데이터를 불러올 가능성이있다고 생각했고, 노트북과 노트는 서로 다른 형태와 목적을 가진 데이터이기 때문에 저장소를 구분하는 것이 맞다고 판단했습니다. 따라서 각각 rm_notebook, rm_note 두 개의 키에 나누어 저장하도록 했습니다.
    - 노트가 어떤 노트북에 속하는지를 판단하기 위해 notebook 키에 참조할 수 있는 노트북 id를 저장하도록 했습니다.
    - 로컬스토리지의 키를 데이터 콜렉션으로 활용하고 있기 때문에 localStorage.removeItem(key)는 불가능하고, 직접 객체를 수정해서 다시 저장하는 방식으로 api들을 구현했습니다.

    - 중복되지 않는 데이터를 구현하기 위해서는 데이터를 구분하기 위한 유니크한 값이 필요했고, 이 값을 생성해주는 라이브러리를 사용하기로 했습니다. 여러 옵션 중 uuid는 너무 길어 많은 용량을 차지할 것이었습니다. cuid는 uuid 보다 짧고 따라서 적은 용량을 차지하지만, uuid 보다는 유니크한 값이 아닐 가능성이 높았습니다.
    - 실제로 사용되는 앱이 아니었기 때문에 상기한 단점을 감수하고서라도 cuid를 사용했습니다.

  2. localStorage 사용 이슈

    - zustand store 구성 시 초기값을 노트북 정보를 getNotebook()을 통해 로컬 스토리지를 가져오도록 했는데, 이 과정이 서버에서 실행 돼 localStorage를 참조하지 못하는 오류가 발생했습니다.
    - 초기값은 비워두고, Notebook 컴포넌트 마운트 시 업데이트 되도록 변경했습니다.

  3. addNote 예외 사항 처리

    - 이미 새로 작성 시작한 노트가 있다면 addNote api가 새로운 노트를 만들지 않아야 하는데, 이를 api에서 처리하기에는 판단에 필요한 요소들을 많이 넘겨줘야 하니 프론트에서 해당 사항을 판단해서 처리하는 것이 낫다고 판단했습니다.
    - addNote 시 content가 null인 새로운 데이터를 생성하는데, 이를 바탕으로 currentNote의 상태를 파악해 content가 null인 경우 api 요청을 보내지 않도록 수정했습니다.

  4. 노트 데이터 저장 시 edittedAt 속성값에 대하여

    - zod z.string().datetime()과 new Date().toString()의 타입이 일치하지 않았습니다.
    - 문자열화 된 Date는 Date 생성자에 인자로 넣을 경우 다시 원래의 Date 객체로 변환되기 때문에, 해당 속성값은 new Date().toString() 형태로 저장하고, 타입을 string으로 체크하기로 했습니다.

  5. 노트북 리스트에서 해당 노트북의 노트 개수 표시 방법에 대하여

    - ListItem 컴포넌트에서 해당 노트북에 속해 있는 노트의 갯수를 표시해야 했습니다.
    - 노트북과 노트의 데이터가 나누어져 저장되기 때문에, 노트북 데이터에 개수 정보를 미리 입력해두는 것을 생각했으나, 이 방법은 데이터가 수정되는 과정에서 오류에 따라 정확성을 잃을 수 있다고 판단했습니다.
    - 따라서 노트 데이터에서 해당 노트북을 부모로 하는, 즉 notebook 속성의 값과 노트북의 id가 일치하는 노트만 필터링해 개수를 판단했습니다.

  6. 노트 delete 시 노트북리스트와 노트리스트의 재렌더링 이슈
    
    - deleteNote 시 노트북 리스트의 노트 개수와, 노트 리스트가 해당 사항을 반영하여 다시 렌더링 돼야 했습니다.
    - 두 리스트 모두 currentNote를 구독하고 있었기 때문에, currentNote의 상태를 { ...currentNote }로 복사하여 강제로 상태를 업데이트 하려고 했지만 이전과 상태가 동일한 경우여서 렌더가 발생하지 않았습니다.
    - noteData 상태를 추가하여 두 리스트가 해당 상태를 구독하고, deleteNote 시 해당 상태를 동기화함으로써 다시 렌더될 수 있도록 조치하였습니다.

  7. 노트 저장 기능 구현

    - UpNote 앱과 유사하게 구현하기 위해, change 및 blur 이벤트 시 노트 내용을 저장하도록 구현했습니다.
    - 같은 동작이 두 이벤트에서 일어나야 하므로, 한 플러그인에서 두 가지를 동시에 컨트롤하도록 구성했습니다.
    - 첫 시도 시 이벤트가 너무 많이 발생해 의도한 대로 작동하지 않았고, 원인을 살펴보면서 currentNote의 전역 상태 변경과 editor의 상태 변경을 분리해서 조작해야겠다는 생각이 들었습니다.
    - currentNote의 상태가 변경되면 새로운 editor를 렌더하도록 하고 싶었으나, initialConfig을 변경하는 방법으로는 불가능 했고, 결국 LexicalComposer에 key값을 부여하여 해결했습니다.
    
    참고: https://github.com/facebook/lexical/discussions/3335#discussioncomment-5644500

  8. 노트 리스트의 ContextnMenu 사용에 대하여

    - ContextMenu 사용 시 해당 노트가 선택되도록 (currentNote의 상태가 변하도록) 설정했고, 이는 currentNote의 상태가 변하며 에디터에 포커스가 이동하도록 만들어 기존의 ContextMenu를 유지하기 위한 포커스가 해제되어 원하는 대로 동작하지 않았습니다.
    - 이후 다른 구현 사항을 수정하면서, UpNote 앱은 노트 선택 시 자동으로 포커스 되지 않는다는 것을 확인하고 에디터에 포커스가 이동되지 않도록 수정하여 해결됐습니다.

  9. placeholder 클릭 시 에디터 포커스 되지 않는 현상

    - placeholder는 아무 기능이 없고 내용이 없음을 표시할 뿐인데, 하나의 html요소로 인식되어 뒤에 있는 editor가 클릭되지 않았습니다.
    - 해당 요소에 pointer-events: none 속성을 부여해 해결했습니다.

  10. input 입력 시 setError가 trigger 되지 않는 현상

    - react-hook-form을 사용하여 사용자에게 실시간으로 validation 오류를 보여주고자 했습니다만, submit 하지 않으면 formState의 errors 상태가 업데이트 되지 않았습니다.
    - 이는 useForm의 mode 기본값이 'onSubmit'이기 때문이고, 인자에 mode를 전달하여 값을 변경할 수 있었습니다.
    - 사용자 입력이 변함에 따라 validation 오류를 보여주고자 했으므로, mode의 값을 onChange로 설정했습니다.


## 미해결 과제 및 아이디어

  1. 노트북 리스트 재귀적 렌더링

    - nested 노트북을 구현할 경우, Listitem을 재귀적으로 렌더링할 필요가 있다고 생각합니다.
    - 가장 상위의 노트북 리스트는 parent === null인 노트북만 렌더하면 될 것 같습니다만, 이후 그 리스트를 순회하며 parent를 비교하며 렌더하고, 이를 재귀적으로 반복하면 될 것 같다고 생각합니다만 아직 구현하지 못했습니다.
  
  2. 페이지 처음 렌더 시에 요소들의 위치가 이상한 현상
    
    - 페이지를 새로고침 하면 처음 렌더 시에 요소들의 위치가 예상한 위치에 있지 않고, 가운데에서 양 옆으로 펼쳐지듯이 나타납니다. (ellipsis 속성을 통해 확연히 드러남)
    - div#App의 width가 조절되며 일어나는 현상이라고 생각하는데, 왜 고정된 값으로 시작하지 않는지 알 수 없습니다.

  3. New Note 기능 업그레이드

    - UpNote의 경우 노트 생성 시 이미 새로운 노트를 생성한 화면이면, 포커스만 이동하고 새로운 노트를 만들지 않습니다.
    - 이와 같이 구현하기 위해서 현재 상태를 어떤 방법으로 판단할지, 또 해당 버튼과 editor가 어떤 식으로 input의 ref를 공유할지에 대해 고민해봐야할 것 같습니다.
    - 이미 빈 노트 화면인지에 대한 판단에서, $getRoot().isEmpty()는 첫 생성 시에도 false를 반환해 이용하기 어려울 것 같습니다.

  4. 노트 목록에서 제목과 내용 미리 보기 표시

    - SerializedEditorState 타입으로 저장된 textNode를 해석하려고 시도했지만, 지금 구조에서 타입을 어떻게 접근해야할지 몰라 any 타입 처리했습니다.
    - 또한 하드코딩으로 구현해 새로운 노드가 추가될 시 정상적으로 표시되지 않을 가능성이 있어 보입니다.
    - 노드의 구성 방식에 대한 이해가 필요하다고 생각합니다.

## 기타 메모

  - editor.update(), editor.registerUpdateListener() 둘은 어떤 차이가 있을까? 둘 다 editor 업데이트에 반응하는 듯한데, 또 editorState.read()와는 사용 방법에 있어서 어떤 차이가 있을까?

  - 왜 나는 viewer와 editor를 나누지 않았는지?

  - debounce를 utils 등 외부 함수로 분리하면 타이머 관리가 편해질까?